#ifndef CAPSTONE_AST
#define CAPSTONE_AST

// Generated by ./scripts/ast_gen.py

#include "common.h"
#include "lexer.h"

class Node {
  public:
    virtual std::string toJSON() = 0;
};

static std::string createList(const std::vector<Node*>&);
static std::string safeLiterals(const std::string& str);
static std::string nullSafeToString(Node*);


class BinaryOperator : public Node {
  public:              
    Node* left;
    Node* right;
    int op;
     
    BinaryOperator(Node* left, Node* right, int op) : left(left), right(right), op(op) {}
    std::string toJSON(void);
};

class FunctionCall : public Node {
  public:              
    Node* callback;
    Node* generic;
    std::vector<Node*> params;
     
    FunctionCall(Node* callback, Node* generic, std::vector<Node*> params) : callback(callback), generic(generic), params(params) {}
    std::string toJSON(void);
};

class NumberLiteral : public Node {
  public:              
    std::string literal;
     
    NumberLiteral(const std::string& literal) : literal(literal) {}
    std::string toJSON(void);
};

class StringLiteral : public Node {
  public:              
    std::string literal;
     
    StringLiteral(const std::string& literal) : literal(literal) {}
    std::string toJSON(void);
};

class BooleanLiteral : public Node {
  public:              
    std::string literal;
     
    BooleanLiteral(const std::string& literal) : literal(literal) {}
    std::string toJSON(void);
};

class NullLiteral : public Node {
  public:              
    std::string literal;
     
    NullLiteral(const std::string& literal) : literal(literal) {}
    std::string toJSON(void);
};

class VariableIdentifier : public Node {
  public:              
    Node* child;
    std::string name;
     
    VariableIdentifier(Node* child, const std::string& name) : child(child), name(name) {}
    std::string toJSON(void);
};

class TypeIdentifier : public Node {
  public:              
    Node* child;
    std::string name;
     
    TypeIdentifier(Node* child, const std::string& name) : child(child), name(name) {}
    std::string toJSON(void);
};

class VariableDeclaration : public Node {
  public:              
    Node* type;
    Node* name;
    Node* value;
     
    VariableDeclaration(Node* type, Node* name, Node* value) : type(type), name(name), value(value) {}
    std::string toJSON(void);
};

class ExpressionStatement : public Node {
  public:              
    Node* expression;
     
    ExpressionStatement(Node* expression) : expression(expression) {}
    std::string toJSON(void);
};

class Block : public Node {
  public:              
    std::vector<Node*> statements;
     
    Block(std::vector<Node*> statements) : statements(statements) {}
    std::string toJSON(void);
};

class IfElseStatement : public Node {
  public:              
    Node* condition;
    Node* ifBlock;
    Node* elseBlock;
     
    IfElseStatement(Node* condition, Node* ifBlock, Node* elseBlock) : condition(condition), ifBlock(ifBlock), elseBlock(elseBlock) {}
    std::string toJSON(void);
};

class WhileStatement : public Node {
  public:              
    Node* condition;
    Node* block;
     
    WhileStatement(Node* condition, Node* block) : condition(condition), block(block) {}
    std::string toJSON(void);
};

class ParameterDeclaration : public Node {
  public:              
    Node* type;
    Node* name;
     
    ParameterDeclaration(Node* type, Node* name) : type(type), name(name) {}
    std::string toJSON(void);
};

class FunctionDeclaration : public Node {
  public:              
    Node* name;
    Node* generic;
    std::vector<Node*> params;
    std::vector<Node*> returns;
    Node* block;
     
    FunctionDeclaration(Node* name, Node* generic, std::vector<Node*> params, std::vector<Node*> returns, Node* block) : name(name), generic(generic), params(params), returns(returns), block(block) {}
    std::string toJSON(void);
};

#endif
